console.log('stash')
console.log('stash list and stash apply')
console.log('stash drop stash@{0} -> delet')

//
// 1. git stash로 변경 사항 저장
// 2. git stash list로 리스트 확인


console.log('stash list')

// branch 확인
console.log('it is first branch')

console.log('fetch')

// git change
console.log('something change')
// check by bash

// How to Merge it?
// git stash push -m 'message' <- to save with message
// and when I save through stash, the latest stash will save as stahs@{0} 

// 취소
// 깃의 reset command to undo a merge.
// 우선, 커밋 hash (혹은 id)를 확인해야 이전의 커밋으로 돌아갈 수 있습니다.
// hash를 확인하기 위해서는 git log 혹은 git reflog를 실행하세요. 
// 더 읽기 쉬운 git reflog가 더 나은 옵션이 될 수 있습니다


// 권한
// git config --global credential.helper wincred


// git merge
// git merge 는 다른 브랜치를 현재 Checkout된 브랜치에 Merge 하는 명령이다. Merge 하고 나서 현재 브랜치가 Merge 된 결과를 가리키도록 옮긴다.
// git merge 명령은 브랜치의 기초에서 설명한다. 이 책의 여러 곳에서 merge 명령을 사용하지만 브랜치의 기초에서 설명한 것에서 크게 벗어나지 않는다. git merge <branch> 명령을 실행하면 해당 브랜치가 Merge 된다.
// 공개 프로젝트 Fork의 끝 부분에서 Squash 해서 Merge 하는 방법도 설명한다. Merge 하는 브랜치의 히스토리는 무시하고 새 커밋을 하나 만들어 Merge 하는 방법이다.
// 고급 Merge에서는 -Xignore-space-change 옵션을 사용하는 방법이나 --abort 플래그로 Merge를 중단하는 방법 등을 설명한다.
// Merge 하기 전에 서명을 검사하는 방법도 설명한다. GPG 서명은 커밋에 서명하기에서 설명한다.
// 마지막으로 Subtree를 Merge 하는 것은 서브트리 Merge에서 배운다.

// git mergetool
// git mergetool 명령은 외부 Merge Helper를 실행해 준다. Merge 하다가 문제가 생겼을 때 사용한다.
// 충돌의 기초에서 살짝 맛을 보여주고 다른 Merge, Diff 도구 사용하기에서 자신의 외부 Merge 도구를 설정하는 방법을 설명한다.

// // Rebase
// - $git rebase <합칠 브랜치>  명령어를 사용
// - Rebase 의 경우, 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하면서 합친다.
// - Rebase 명령으로 한 브랜치에서 변경된 사항을 다른 브랜치에 적용할 수 있다.
//  
// - 사용) 리모트 브랜치에 커밋을 깔끔하게 적용하고 싶을 때
//  
// - 장점)  merge보다 좀 더 깨끗한 히스토리를 만든다.
//            ㄴ> Rebase한 브랜치의 로그를 보면 히스토리가 선형이다.            
//            ㄴ> 일을 병렬로 동시에 진행해도 Rebase 하고 나면 모든 작업이 차례대로 수행된 것처럼 보인다.
// - 단점) 아래에서 설명할 'Rebase 의 위험성'이 있다- "Rebase 하는 리모트 브랜치는 직접 관리하는 것이 아니라 그냥 참여하는 브랜치일 것이다."   
//            ㄴ> 메인 프로젝트에 Patch를 보낼 준비가 되면 하는 것이 Rebase이므로 브랜치에서 하던 일을 완전히 마치고 origin/main으로 Rebase 한다. 
//                이렇게 Rebase 하고 나면 프로젝트 관리자는 어떠한 통합작업도 필요 없다.          
//                그냥 main 브랜치를 Fast-forward 시키면 된다.
//  
//  
// - [Rebase과정]
//   ⓐ 일단 두 브랜치가 나뉘기 전인 공통 커밋으로 이동  
//   ⓑ 공통 커밋부터 지금 Checkout 한 브랜치가 가리키는 커밋까지 diff를 차례로 만들어 어딘가에 임시로 저장해 놓는다.   
//   ⓒ 'Rebase 할 브랜치'가 '합칠 브랜치'가 가리키는 커밋을 가리키게 하고   
//   ⓓ 아까 저장해 놓았던 변경사항을 차례대로 적용한다.  
//   ⓔ 그리고 나서 main 브랜치를 Fast-forward 시킨다. (=main  브랜치를 최신 커밋으로 옮긴다.)



// 충돌 해결 방법
// 깃(Git) 충돌 시 해결 방법
// Git에서 브랜치를 병합할 때, 때로는 충돌이 발생할 수 있습니다. 이는 다른 개발자가 동일한 파일을 수정하거나, 같은 파일을 다른 방식으로 수정한 경우 등에 발생할 수 있습니다. 
// 충돌을 해결하지 않으면, 코드의 불일치로 인해 컴파일 오류 등의 문제가 발생할 수 있습니다. 이러한 충돌을 해결하는 방법은 다음과 같습니다.

// 에러 메시지 확인하기
// 먼저, 충돌이 발생한 파일을 열어 Git 메시지를 확인합니다. Git은 충돌이 발생한 파일에 다음과 같은 메시지를 추가합니다.

// // 현재 브랜치의 변경 사항
// // 병합할 브랜치의 변경 사항
// 위의 메시지에서 <<<<<<< HEAD는 현재 브랜치의 변경 사항을, >>>>>>> [브랜치 이름]은 병합할 브랜치의 변경 사항을 나타냅니다.

// 충돌 해결하기
// 다음으로, 충돌이 발생한 파일을 열어 변경 사항을 확인하고, 충돌을 해결합니다. 일반적으로 다음과 같은 방법으로 충돌을 해결할 수 있습니다.

// 원하는 변경 사항 선택하기
// 현재 브랜치 또는 병합할 브랜치에서 원하는 변경 사항을 선택합니다. 이를 위해 Git 메시지에서 <<<<<<< HEAD와 >>>>>>> [브랜치 이름] 사이의 변경 사항 중 하나를 선택합니다.

// 충돌 해결하기
// 선택한 변경 사항을 기반으로 충돌을 해결합니다. 예를 들어, <<<<<<< HEAD와 >>>>>>> [브랜치 이름] 사이에 있는 변경 사항을 합치거나, 삭제하거나, 수정할 수 있습니다.

// 변경 사항 저장하기
// 충돌을 해결한 후, 변경 사항을 저장합니다. 이를 위해 Git 메시지에서 <<<<<<< HEAD와 >>>>>>> [브랜치 이름] 사이의 변경 사항을 제거하고, 변경된 파일을 다시 저장합니다.

// 커밋하기
// 충돌을 해결한 후, 변경 사항을 커밋합니다. 이를 위해 다음과 같이 Git 명령어를 사용합니다.

// $ git add [해결된 파일]
// $ git commit -m "충돌 해결"
// 이렇게 하면 충돌이 해결되고, 변경 사항이 커밋됩니다.

// 결론
// 이러한 방식으로 충돌을 해결하면, 브랜치를 병합하면서 발생할 수 있는 문제를 해결할 수 있습니다. 충돌을 처리하는 과정은 다소 복잡할 수 있지만, 
// Git을 사용하면 효과적으로 코드를 관리할 수 있습니다. 따라서 개발자들은 Git에서 충돌을 해결하는 방법에 대해 익숙해지는 것이 중요합니다.